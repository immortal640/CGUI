//
// This file has been generated by the free and online chatbot ChatGPT-4o
// The file has been heavily modified by @immortal640
//

using System.Runtime.InteropServices;
using System.Text;
using PInvoke;

namespace TOOLS
{
    public static class Keyboard
    {
        // Import required Windows API functions
        [DllImport("user32.dll")]
        private static extern IntPtr GetKeyboardLayout(uint threadId);
        [DllImport("user32.dll")]
        private static extern int ToUnicodeEx(uint wVirtKey, uint wScanCode, byte[] lpKeyState,
            [Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff,
            int cchBuff, uint wFlags, IntPtr dwhkl);
        [DllImport("user32.dll")]
        private static extern bool GetKeyboardState(byte[] lpKeyState);
        [DllImport("user32.dll")]
        private static extern short GetAsyncKeyState(int vKey);

        
        /// <summary>
        /// This is a reimplemented <c>Console.ReadKey()</c> function.
        /// It has been designed to be cancelled at any time.
        /// This function has a customisable 'breakout key'.
        /// </summary>
        /// <param name="token">The Cancellation token used to immediately cancel the function</param>
        /// <param name="breakout">A customisable breakout key</param>
        /// <param name="def">The default value</param>
        /// <returns>The received character in form of a string.</returns>
        public static ConsoleKeyInfo ReadKey(CancellationToken token, ConsoleKeyInfo breakout, ConsoleKeyInfo? def = null)
        {
            try
            {
                IntPtr layout = GetKeyboardLayout(0);
                def ??= new ConsoleKeyInfo('\0', 0, false, false, false);
                
                while (true)
                {
                    for (int key = 8; key <= 255; key++)
                    {
                        if (token.IsCancellationRequested)
                            return (ConsoleKeyInfo)def;
                        
                        if ((GetAsyncKeyState(key) & 0x8000) != 0)
                        {
                            byte[] keyState = new byte[256];
                            if (!GetKeyboardState(keyState))
                                continue;

                            bool shiftPressed = (keyState[0x10] & 0x80) != 0;
                            bool altPressed = (keyState[0x12] & 0x80) != 0;
                            bool ctrlPressed = (keyState[0x11] & 0x80) != 0;

                            string? charResult = GetCharFromKey(key, layout, keyState);
                            char keyChar = charResult?.Length > 0 ? charResult[0] : '\0';
                            ConsoleKey consoleKey = (ConsoleKey)key;

                            if (new ConsoleKeyInfo(keyChar, consoleKey, shiftPressed, altPressed, ctrlPressed) == breakout)
                                return (ConsoleKeyInfo)def;
                            return new ConsoleKeyInfo(keyChar, consoleKey, shiftPressed, altPressed, ctrlPressed);
                        }
                    }
                }
            }
            catch (Exception)
            {
                return new ConsoleKeyInfo('\0', 0, false, false, false);
            }
        }
        /// <summary>
        /// This is a reimplemented <c>Console.ReadKey()</c> function.
        /// It has been designed to be cancelled at any time.
        /// </summary>
        /// <param name="token">The Cancellation token used to immediately cancel the function</param>
        /// <param name="def">The default value</param>
        /// <returns>The received character in form of a string.</returns>
        public static ConsoleKeyInfo ReadKey(CancellationToken token, ConsoleKeyInfo? def = null)
        {
            try
            {
                IntPtr layout = GetKeyboardLayout(0);
                def ??= new ConsoleKeyInfo('\0', 0, false, false, false);
                
                while (true)
                {
                    for (int key = 8; key <= 255; key++)
                    {
                        if (token.IsCancellationRequested)
                            return (ConsoleKeyInfo)def;
                        
                        if ((GetAsyncKeyState(key) & 0x8000) != 0)
                        {
                            byte[] keyState = new byte[256];
                            if (!GetKeyboardState(keyState))
                                continue;

                            bool shiftPressed = (keyState[0x10] & 0x80) != 0;
                            bool altPressed = (keyState[0x12] & 0x80) != 0;
                            bool ctrlPressed = (keyState[0x11] & 0x80) != 0;

                            string? charResult = GetCharFromKey(key, layout, keyState);
                            char keyChar = charResult?.Length > 0 ? charResult[0] : '\0';
                            ConsoleKey consoleKey = (ConsoleKey)key;

                            return new ConsoleKeyInfo(keyChar, consoleKey, shiftPressed, altPressed, ctrlPressed);
                        }
                    }
                }
            }
            catch (Exception)
            {
                return new ConsoleKeyInfo('\0', 0, false, false, false);
            }
        }
        /// <summary>
        /// This is a reimplemented <c>Console.ReadKey()</c> function.
        /// This function has a customisable 'breakout key'.
        /// </summary>
        /// <param name="breakout">A customisable breakout key</param>
        /// <param name="def">The default value</param>
        /// <returns>The received character in form of a string.</returns>
        public static ConsoleKeyInfo ReadKey(ConsoleKeyInfo breakout, ConsoleKeyInfo? def = null)
        {
            try
            {
                IntPtr layout = GetKeyboardLayout(0);
                def ??= new ConsoleKeyInfo('\0', 0, false, false, false);
                
                while (true)
                {
                    for (int key = 8; key <= 255; key++)
                    {
                        if ((GetAsyncKeyState(key) & 0x8000) != 0)
                        {
                            byte[] keyState = new byte[256];
                            if (!GetKeyboardState(keyState))
                                continue;

                            bool shiftPressed = (keyState[0x10] & 0x80) != 0;
                            bool altPressed = (keyState[0x12] & 0x80) != 0;
                            bool ctrlPressed = (keyState[0x11] & 0x80) != 0;

                            string? charResult = GetCharFromKey(key, layout, keyState);
                            char keyChar = charResult?.Length > 0 ? charResult[0] : '\0';
                            ConsoleKey consoleKey = (ConsoleKey)key;

                            if (new ConsoleKeyInfo(keyChar, consoleKey, shiftPressed, altPressed, ctrlPressed) == breakout)
                                return (ConsoleKeyInfo)def;
                            return new ConsoleKeyInfo(keyChar, consoleKey, shiftPressed, altPressed, ctrlPressed);
                        }
                    }
                }
            }
            catch (Exception)
            {
                return new ConsoleKeyInfo('\0', 0, false, false, false);
            }
        }
        /// <summary>
        /// This is a reimplemented <c>Console.ReadKey()</c> function.
        /// </summary>
        /// <param name="def">The default value</param>
        /// <returns>The received character in form of a string.</returns>
        public static ConsoleKeyInfo ReadKey(ConsoleKeyInfo? def = null)
        {
            try
            {
                IntPtr layout = GetKeyboardLayout(0);
                def ??= new ConsoleKeyInfo('\0', 0, false, false, false);
                
                while (true)
                {
                    for (int key = 8; key <= 255; key++)
                    {
                        if ((GetAsyncKeyState(key) & 0x8000) != 0)
                        {
                            byte[] keyState = new byte[256];
                            if (!GetKeyboardState(keyState))
                                continue;

                            bool shiftPressed = (keyState[0x10] & 0x80) != 0;
                            bool altPressed = (keyState[0x12] & 0x80) != 0;
                            bool ctrlPressed = (keyState[0x11] & 0x80) != 0;

                            string? charResult = GetCharFromKey(key, layout, keyState);
                            char keyChar = charResult?.Length > 0 ? charResult[0] : '\0';
                            ConsoleKey consoleKey = (ConsoleKey)key;

                            return new ConsoleKeyInfo(keyChar, consoleKey, shiftPressed, altPressed, ctrlPressed);
                        }
                    }
                }
            }
            catch (Exception)
            {
                return new ConsoleKeyInfo('\0', 0, false, false, false);
            }
        }


        /// <summary>
        /// This is a reimplemented <c>Console.ReadLine()</c> function.
        /// It has been designed to be cancelled at any time.
        /// This function has a customisable 'breakout key'.
        /// </summary>
        /// <param name="token">The Cancellation token used to immediately cancel the function</param>
        /// <param name="breakout">A customisable breakout key</param>
        /// <param name="breakoutCancellation">If <c>true</c>, it will return the default value is returned, otherwise the entered text.</param>
        /// <param name="def">The default value</param>
        /// <returns>The received character in form of a string.</returns>
        public static string ReadLine(CancellationToken token, ConsoleKeyInfo breakout, bool breakoutCancellation, string? def = null, bool exitOnEnter = true)
        {
            try
            {
                def ??= "";
                string? result = "";
                bool[] keyStates = new bool[256];

                while (true)
                {
                    if (token.IsCancellationRequested)
                        return def;

                    IntPtr layout = GetKeyboardLayout(0);

                    for (int key = 8; key <= 255; key++)
                    {
                        bool pressed = (GetAsyncKeyState(key) & 0x8000) != 0;

                        if (pressed && !keyStates[key])
                        {
                            keyStates[key] = true;
                            
                            byte[] keyState = new byte[256];
                            if (!GetKeyboardState(keyState))
                                continue;

                            bool shiftPressed = (keyState[0x10] & 0x80) != 0;
                            bool altPressed = (keyState[0x12] & 0x80) != 0;
                            bool ctrlPressed = (keyState[0x11] & 0x80) != 0;

                            if (key == (int)breakout.Key)
                            {
                                if (shiftPressed != ((breakout.Modifiers & ConsoleModifiers.Shift) != 0))
                                    continue;
                                if (altPressed != ((breakout.Modifiers & ConsoleModifiers.Shift) != 0))
                                    continue;
                                if (ctrlPressed != ((breakout.Modifiers & ConsoleModifiers.Shift) != 0))
                                    continue;
                                if (breakoutCancellation)
                                    return def;
                                return result;
                            }
                            if (key == (int)ConsoleKey.Backspace)
                            {
                                if (result.Length > 0)
                                    result = result.Substring(0, result.Length - 1);
                            }

                            if (key == (int)ConsoleKey.Enter && exitOnEnter)
                            {
                                return result;
                            }
                            string? charToAppend = GetCharFromKey(key, layout, keyState);
                            charToAppend ??= "";
                            if (!string.IsNullOrEmpty(charToAppend))
                            {
                                if (shiftPressed)
                                {
                                    char[] charArray = charToAppend.ToCharArray();
                                    charArray[0] += (char)10;
                                    charToAppend = new string(charArray);
                                }
                                result += charToAppend;
                            }
                        }
                        else if (!pressed) // Key released
                        {
                            keyStates[key] = false;
                        }
                    }

                    // Simulate a small processing delay
                    Thread.Sleep(1);
                }
            }
            catch (Exception ex)
            {
                return $"Error occurred: {ex.Message}";
            }
        }
        
        
        private static string? GetCharFromKey(int virtualKey, IntPtr keyboardLayout, byte[] keyState)
        {
            StringBuilder sb = new StringBuilder(2);
            int result = ToUnicodeEx((uint)virtualKey, 0, keyState, sb, sb.Capacity, 0, keyboardLayout);

            return result > 0 ? sb.ToString() : null;
        }
    }
}
